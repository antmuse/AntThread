!<arch>
//                                              18        `
CThreadEvent.cpp/
IAppLogger.cpp/ 1500521024  1000  1000  100644  1449      `
﻿#include <time.h>
#include <stdio.h>
#include <stdarg.h>
#include <wchar.h>
#include "IAppLogger.h"


namespace irr {

	c8 IAppLogger::mTextBuffer[MAX_TEXT_BUFFER_SIZE];
	wchar_t IAppLogger::mTextBufferW[MAX_TEXT_BUFFER_SIZE];

#if defined(APP_DEBUG)
	ELogLevel IAppLogger::mMinLogLevel = ELOG_DEBUG;
#else
	ELogLevel IAppLogger::mMinLogLevel = ELOG_INFO;
#endif

	IAppLogger::IAppLogger() {

	}

	IAppLogger::~IAppLogger() {
	}

	void IAppLogger::setLevel(ELogLevel iLevel){
		mMinLogLevel = iLevel;
	}

	void IAppLogger::log(ELogLevel iLevel, const wchar_t* iSender, const wchar_t* iFormat, ...) {
		if (iLevel >= mMinLogLevel) {
			va_list args;
			va_start(args, iFormat);
#if defined(APP_PLATFORM_WINDOWS)
			_vsnwprintf(mTextBufferW, MAX_TEXT_BUFFER_SIZE, iFormat, args);
			wprintf(L"[%s]  %s >> %s\n", AppLogLevelStringsW[iLevel], iSender, mTextBufferW);
#elif defined(APP_PLATFORM_LINUX)
			vswprintf(mTextBufferW, MAX_TEXT_BUFFER_SIZE, iFormat, args);
			printf("[%ls]  %ls >> %ls\n", AppLogLevelStringsW[iLevel], iSender, mTextBufferW);
#endif //
			va_end(args);
		}
	}

	void IAppLogger::log(ELogLevel iLevel, const c8* iSender, const c8* iFormat, ...) {
		if (iLevel >= mMinLogLevel) {
			va_list args;
			va_start(args, iFormat);
			vsnprintf(mTextBuffer, MAX_TEXT_BUFFER_SIZE, iFormat, args);
			printf("[%s]  %s >> %s\n", AppLogLevelStrings[iLevel], iSender, mTextBuffer);
			va_end(args);
		}
	}

}//namespace irr {

/0              1499040842  1000  1000  100644  4230      `
﻿#include "CThreadEvent.h"
#if defined(APP_PLATFORM_WINDOWS)
#include <windows.h>
#elif defined(APP_PLATFORM_LINUX)
//
#endif

namespace irr {


#if defined(APP_PLATFORM_WINDOWS)

	CThreadEvent::CThreadEvent(fschar_t* iName/* = 0*/, bool autoReset/* = true*/){
		mHandle = CreateEvent(NULL, autoReset ? FALSE : TRUE, FALSE, iName);
		if (!mHandle){
			//("cannot create event");
		}
	}


	CThreadEvent::~CThreadEvent(){
		CloseHandle(mHandle);
	}


	void CThreadEvent::set(){
		if (!SetEvent(mHandle))	{
			//throw SystemException("cannot signal event");
		}
	}


	void  CThreadEvent::reset(){
		if (!ResetEvent(mHandle))	{
			//throw SystemException("cannot reset event");
		}
	}


	bool CThreadEvent::wait(){
		switch (WaitForSingleObject(mHandle, INFINITE)) {
		case WAIT_OBJECT_0:
			return true;
		default:
			break;//throw SystemException("wait for event failed");
		}
		return false;
	}


	bool CThreadEvent::wait(long milliseconds){
		switch (WaitForSingleObject(mHandle, milliseconds + 1)) {
		case WAIT_TIMEOUT:
			return false;
		case WAIT_OBJECT_0:
			return true;
		default:
			break; //throw SystemException("wait for event failed");		
		}
		return false;
	}




#elif defined(APP_PLATFORM_LINUX)

	CThreadEvent::CThreadEvent(fschar_t* iName/* = 0*/, bool autoReset/* = true*/) : mAutoReset(autoReset), mStatus(false) {
		if (pthread_mutex_init(&mMutex, NULL)){
			// SystemException("cannot create event (mutex)");
		}
		pthread_condattr_t attr;
		if (pthread_condattr_init(&attr))	{
			pthread_mutex_destroy(&mMutex);
			// SystemException("cannot create event (condition attribute)");
		}
		if (pthread_condattr_setclock(&attr, CLOCK_MONOTONIC))   {
			pthread_condattr_destroy(&attr);
			pthread_mutex_destroy(&mMutex);
			// SystemException("cannot create event (condition attribute clock)");
		}
		if (pthread_cond_init(&mCond, &attr))	{
			pthread_condattr_destroy(&attr);
			pthread_mutex_destroy(&mMutex);
			// SystemException("cannot create event (condition)");
		}
		pthread_condattr_destroy(&attr);
	}


	CThreadEvent::~CThreadEvent(){
		pthread_cond_destroy(&mCond);
		pthread_mutex_destroy(&mMutex);
	}


	void CThreadEvent::set(){
		if (pthread_mutex_lock(&mMutex)){
			// SystemException("cannot signal event (lock)");
		}
		mStatus = true;
		if (pthread_cond_broadcast(&mCond))	{
			pthread_mutex_unlock(&mMutex);
			// SystemException("cannot signal event");
		}
		pthread_mutex_unlock(&mMutex);
	}


	void  CThreadEvent::reset(){
		if (pthread_mutex_lock(&mMutex)){
			// SystemException("cannot reset event");
		}
		mStatus = false;
		pthread_mutex_unlock(&mMutex);
	}


	bool CThreadEvent::wait(){
		if (pthread_mutex_lock(&mMutex)){
			// SystemException("wait for event failed (lock)");
		}
		while (!mStatus) 	{
			if (pthread_cond_wait(&mCond, &mMutex))	{
				pthread_mutex_unlock(&mMutex);
				// SystemException("wait for event failed");
			}
		}
		if (mAutoReset){
			mStatus = false;
		}
		pthread_mutex_unlock(&mMutex);
	}


	bool CThreadEvent::wait(long milliseconds){
		s32 rc = 0;
		struct timespec abstime;
		clock_gettime(CLOCK_MONOTONIC, &abstime);
		abstime.tv_sec  += milliseconds / 1000;
		abstime.tv_nsec += (milliseconds % 1000)*1000000;
		if (abstime.tv_nsec >= 1000000000)	{
			abstime.tv_nsec -= 1000000000;
			abstime.tv_sec++;
		}
#if 0
		struct timeval tv;
		gettimeofday(&tv, NULL);
		abstime.tv_sec  = tv.tv_sec + milliseconds / 1000;
		abstime.tv_nsec = tv.tv_usec*1000 + (milliseconds % 1000)*1000000;
		if (abstime.tv_nsec >= 1000000000)	{
			abstime.tv_nsec -= 1000000000;
			abstime.tv_sec++;
		}
#endif


		if (pthread_mutex_lock(&mMutex) != 0){
			// SystemException("wait for event failed (lock)");
		}
		while (!mStatus) 	{
			if ((rc = pthread_cond_timedwait(&mCond, &mMutex, &abstime)))	{
				if (rc == ETIMEDOUT) break;
				pthread_mutex_unlock(&mMutex);
				// SystemException("cannot wait for event");
			}
		}
		if (rc == 0 && mAutoReset){
			mStatus = false;
		}
		pthread_mutex_unlock(&mMutex);

		return rc == 0;
	}

#endif //APP_PLATFORM_LINUX


} //end namespace irrCMutex.cpp/     1502673880  1000  1000  100644  3429      `
﻿#include "CMutex.h"
#include "irrTypes.h"

#if defined( APP_PLATFORM_WINDOWS )
namespace irr {

	CMutex::CMutex(EMutexType type/* = EMT_RECURSIVE*/){
		InitializeCriticalSectionAndSpinCount(&mCriticalSection, 4000);
	}

	CMutex::~CMutex(){
		DeleteCriticalSection(&mCriticalSection);
	}

	bool CMutex::tryLock(long milliseconds){
		const s32 sleepMillis = 5;
		u32 iTime = 0;
		do{
			if (TryEnterCriticalSection(&mCriticalSection) == TRUE){
				return true;
			}
			Sleep(sleepMillis);
			iTime += sleepMillis;
		}while (iTime<=milliseconds);

		return false;
	}

	void CMutex::lock(){
		EnterCriticalSection(&mCriticalSection);
	}

	bool CMutex::tryLock(){
		return TryEnterCriticalSection(&mCriticalSection) != 0;
	}

	void CMutex::unlock(){
		LeaveCriticalSection(&mCriticalSection);
	}


} //namespace irr 

#elif defined( APP_PLATFORM_ANDROID )  || defined( APP_PLATFORM_LINUX )
namespace irr {

	CMutex::CMutex(EMutexType type/* = EMT_RECURSIVE*/){
		pthread_mutexattr_t attr;
		pthread_mutexattr_init(&attr);
		pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_PRIVATE);
		switch(type){
		default:
		case EMT_RECURSIVE:
			//pthread_mutexattr_settype_np(&attr, PTHREAD_MUTEX_RECURSIVE_NP);
			pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
			break;
		case EMT_NO_RECURSIVE:
			//pthread_mutexattr_settype_np(&attr, PTHREAD_MUTEX_NORMAL_NP);
			pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL);
			break;
		}
		if (pthread_mutex_init(&mMutex, &attr))	{
			//("cannot create mutex");		}
		pthread_mutexattr_destroy(&attr);
	}


	CMutex::~CMutex(){
		pthread_mutex_destroy(&mMutex);
	}


	bool CMutex::tryLock(long milliseconds){
#if defined(POCO_HAVE_MUTEX_TIMEOUT)
		struct timespec abstime;
		struct timeval tv;
		gettimeofday(&tv, NULL);
		abstime.tv_sec  = tv.tv_sec + milliseconds / 1000;
		abstime.tv_nsec = tv.tv_usec*1000 + (milliseconds % 1000)*1000000;
		if (abstime.tv_nsec >= 1000000000){
			abstime.tv_nsec -= 1000000000;
			abstime.tv_sec++;
		}
		s32 rc = pthread_mutex_timedlock(&mMutex, &abstime);
		if (rc == 0){
			return true;
		}else if (rc == ETIMEDOUT){
			return false;
		}else{
			//throw SystemException("cannot lock mutex");
		}
#else
		const s32 sleepMillis = 5;
		u32 iTime = ITimer::getTime();
		do{
			s32 rc = pthread_mutex_trylock(&mMutex);
			if (rc == 0){
				return true;
			}else if (rc != EBUSY){
				//throw ("cannot lock mutex");
			}
#if defined(POCO_VXWORKS)
			struct timespec ts;
			ts.tv_sec = 0;
			ts.tv_nsec = sleepMillis*1000000;
			nanosleep(&ts, NULL);
#else
			struct timeval tv;
			tv.tv_sec  = 0;
			tv.tv_usec = sleepMillis * 1000;
			select(0, NULL, NULL, NULL, &tv);
#endif
		}while (ITimer::getTime()-iTime <= milliseconds);

		return false;
#endif
	}


	void CMutex::lock(){
		if (pthread_mutex_lock(&mMutex)) {
			//("cannot lock mutex");
		}
	}


	bool CMutex::tryLock(){
		switch(pthread_mutex_trylock(&mMutex)){
		case 0:
			return true;
		case EBUSY: //The mutex could not be acquired because it was already locked.
			return false;
		case EINVAL: //mutex have not been initialized.
		case EAGAIN: //exceed max lock count.
		default:
			return false;
		}
	}


	void CMutex::unlock(){
		if (pthread_mutex_unlock(&mMutex)){
			//("cannot unlock mutex");
		}
	}


} //namespace irr 
#endif
CThread.cpp/    1502682946  1000  1000  100644  12434     `
﻿#include "CThread.h"
#include "IRunnable.h"

namespace irr {

	CThread::CCurrentThreadHolder CThread::mCurrentHolder;


#if defined( APP_PLATFORM_WINDOWS )

#if defined(_DEBUG)
	const DWORD MS_VC_EXCEPTION = 0x406D1388;

#pragma pack(push,8)
	struct SThreadNameInfo {
		DWORD dwType;     // Must be 0x1000.
		LPCSTR szName;    // Pointer to name (in user addr space).
		DWORD dwThreadID; // CThread ID (-1=caller thread).
		DWORD dwFlags;    // Reserved for future use, must be zero.
	};
#pragma pack(pop)

	void setThreadName(DWORD dwThreadID, const char* threadName){
		if (IsDebuggerPresent())	{
			SThreadNameInfo info;
			info.dwType     = 0x1000;
			info.szName     = threadName;
			info.dwThreadID = dwThreadID;
			info.dwFlags    = 0;
			__try{
				RaiseException(MS_VC_EXCEPTION, 0, sizeof(info)/sizeof(ULONG_PTR), (ULONG_PTR*)&info);
			}__except (EXCEPTION_CONTINUE_EXECUTION){
			}
		}
	}
#endif


	CThread::CThread(): mID(getUniqueID()), 
		mEvent(0,true),
		mRunnableTarget(0),
		mThread(0),
		mThreadID(0),
		mPriority(PRIO_NORMAL),
		mPolicy(POLICY_DEFAULT),
		mStackSize(APP_THREAD_STACK_SIZE){
			makeName();
	}


	CThread::CThread(const core::stringc& name) : mID(getUniqueID()), 
		mEvent(0,true),
		mRunnableTarget(0),
		mThread(0),
		mThreadID(0),
		mPriority(PRIO_NORMAL),
		mPolicy(POLICY_DEFAULT),
		mStackSize(APP_THREAD_STACK_SIZE),
		mName(name){
	}


	CThread::~CThread(){
		if (mThread){
			CloseHandle(mThread);
		}
	}


	void CThread::setPriority(EThreadPriority iPriority){
		if (iPriority != mPriority){
			mPriority = iPriority;
			if (mThread)	{
				if (SetThreadPriority(mThread, mPriority) == 0){
					//throw SystemException("cannot set thread priority");
				}
			}
		}
	}


	void CThread::start(IRunnable& target){
		if (isRunning()){
			return;  //throw SystemException("thread already running");
		}
		mRunnableTarget = &target;
		createThread(runnableEntry, this);
	}


	void CThread::start(AppCallable iTarget, void* iData){
		if (isRunning()){
			return; //throw SystemException("thread already running");
		}
		threadCleanup();
		mCallbackTarget.mCallback = iTarget;
		mCallbackTarget.mData = iData;
		createThread(callableEntry, this);
	}


	void CThread::createThread(AppThreadEntry ent, void* pData){
#if defined(_DLL)
		mThread = CreateThread(NULL, mStackSize, ent, pData, 0, &mThreadID);
#else
		u32 threadId;
		mThread = (HANDLE) _beginthreadex(0, mStackSize, ent, this, 0, &threadId);
		mThreadID = static_cast<DWORD>(threadId);
#endif
		if (!mThread){
			//throw SystemException("cannot create thread");
		}
		if (mPriority != PRIO_NORMAL && !SetThreadPriority(mThread, mPriority)){
			//throw SystemException("cannot set thread priority");
		}
	}


	void CThread::join(){
		if (!mThread){
			return;
		}
		switch (WaitForSingleObject(mThread, INFINITE)){
		case WAIT_OBJECT_0:
			threadCleanup();
			return;
		default:
			//throw SystemException("cannot join thread");
			return;
		}
	}


	bool CThread::join(long milliseconds){
		if (!mThread){
			return true;
		}
		switch (WaitForSingleObject(mThread, milliseconds + 1)){
		case WAIT_TIMEOUT:
			return false;
		case WAIT_OBJECT_0:
			threadCleanup();
			return true;
		default:
			//throw SystemException("cannot join thread");
			return false;
		}
	}


	bool CThread::isRunning() const {
		if (mThread){
			DWORD ec = 0;
			return GetExitCodeThread(mThread, &ec) && ec == STILL_ACTIVE;
		}
		return false;
	}


	void CThread::sleep(long milliseconds){
		Sleep(DWORD(milliseconds));
	}


	void CThread::yield(){
		Sleep(0);
	}


	void CThread::threadCleanup(){
		if (!mThread){
			return;
		}
		if (CloseHandle(mThread)){
			mThread = 0;
		}
	}


	CThread* CThread::getCurrentThread(){
		return mCurrentHolder.get();
	}


	CThread::TID CThread::getCurrentNativeID(){
		return GetCurrentThreadId();
	}


	s32 CThread::getMinPriority(s32 iPolicy/* = POLICY_DEFAULT*/){
		return PRIO_LOWEST;
	}


	s32 CThread::getMaxPriority(s32 iPolicy/* = POLICY_DEFAULT*/){
		return PRIO_HIGHEST;
	}


#if defined(_DLL)
	DWORD WINAPI CThread::runnableEntry(LPVOID iThread) {
#else
	unsigned __stdcall CThread::runnableEntry(void* iThread) {
#endif
		CThread* pTI = reinterpret_cast<CThread*>(iThread);
		mCurrentHolder.set(pTI);
#if defined(APP_DEBUG)
		setThreadName(-1, pTI->getName().c_str());
#endif
		pTI->mRunnableTarget->run();
		pTI->mRunnableTarget = 0;
		return 0;
	}


#if defined(_DLL)
	DWORD WINAPI CThread::callableEntry(LPVOID iThread) {
#else
	unsigned __stdcall CThread::callableEntry(void* iThread) {
#endif
		CThread* pTI = reinterpret_cast<CThread*>(iThread);
		mCurrentHolder.set(pTI);
#if defined(APP_DEBUG)
		setThreadName(-1, pTI->getName().c_str());
#endif
		pTI->mCallbackTarget.mCallback(pTI->mCallbackTarget.mData);
		pTI->mCallbackTarget.mCallback = 0;
		pTI->mCallbackTarget.mData = 0;
		return 0;
	}


#endif			//APP_PLATFORM_WINDOWS






#if defined( APP_PLATFORM_ANDROID )  || defined( APP_PLATFORM_LINUX )
#include <time.h>


	CThread::CThread() : mID(getUniqueID()),
		mEvent(0,true),
		mRunnableTarget(0),
		mThreadID(0),
		mPriority(PRIO_NORMAL),
		mPolicy(POLICY_DEFAULT),
		mStackSize(APP_THREAD_STACK_SIZE) {
			makeName();
	}

	CThread::CThread(const core::stringc& name) : mID(getUniqueID()),
		mEvent(0,true),
		mRunnableTarget(0),
		mThreadID(0),
		mPriority(PRIO_NORMAL),
		mPolicy(POLICY_DEFAULT),
		mStackSize(APP_THREAD_STACK_SIZE),
		mName(name){
	}

	CThread::~CThread(){
		if (isRunning()){
			pthread_detach(mThreadID);
		}
	}


	bool CThread::isRunning() const {
		return mRunnableTarget ||	(mCallbackTarget.mCallback && mCallbackTarget.mData);
	}


	void CThread::yield() {
		sched_yield();
	}

	void CThread::setPriority(EThreadPriority iPriority){
		if (iPriority != mPriority)	{
			mPriority = iPriority;
			if (isRunning())	{
				struct sched_param par;
				par.sched_priority = mapPrio(mPriority, SCHED_OTHER);
				if (pthread_setschedparam(mThreadID, SCHED_OTHER, &par)){
					//throw SystemException("cannot set thread priority");
				}
			}
		}
	}


	s32 CThread::getMinPriority(s32 iPolicy/* = POLICY_DEFAULT*/){
		return sched_get_priority_min(iPolicy);
	}


	s32 CThread::getMaxPriority(s32 iPolicy/* = POLICY_DEFAULT*/){
		return sched_get_priority_max(iPolicy);
	}


	void CThread::start(IRunnable& target){
		if (mRunnableTarget){
			//throw SystemException("thread already running");
			return;
		}
		pthread_attr_t attributes;
		pthread_attr_init(&attributes);

		if (mStackSize != 0){
			if (0 != pthread_attr_setstacksize(&attributes, mStackSize))	{
				pthread_attr_destroy(&attributes);	
				//throw SystemException("cannot set thread stack size");
			}
		}

		mRunnableTarget = &target;
		if (pthread_create(&mThreadID, &attributes, runnableEntry, this)){
			mRunnableTarget = 0;
			pthread_attr_destroy(&attributes);	
			//throw SystemException("cannot start thread");
		}
		pthread_attr_destroy(&attributes);

		if (mPolicy == SCHED_OTHER){
			if (mPriority != PRIO_NORMAL)	{
				struct sched_param par;
				par.sched_priority = mapPrio(mPriority, SCHED_OTHER);
				if (pthread_setschedparam(mThreadID, SCHED_OTHER, &par)){
					//throw SystemException("cannot set thread priority");
				}
			}
		}else{
			struct sched_param par;
			par.sched_priority = mapPrio(mPriority, mPolicy);
			if (pthread_setschedparam(mThreadID, mPolicy, &par)){
				//throw SystemException("cannot set thread priority");
			}
		}
	}


	void CThread::start(AppCallable target, void* pData){
		if (mCallbackTarget.mCallback){
			//throw SystemException("thread already running");
			return;
		}
		pthread_attr_t attributes;
		pthread_attr_init(&attributes);

		if (mStackSize != 0)	{
			if (0 != pthread_attr_setstacksize(&attributes, mStackSize)){
				//throw SystemException("can not set thread stack size");
			}
		}

		mCallbackTarget.mCallback = target;
		mCallbackTarget.mData = pData;

		if (pthread_create(&mThreadID, &attributes, callableEntry, this)){
			mCallbackTarget.mCallback = 0;
			mCallbackTarget.mData = 0;
			//throw SystemException("cannot start thread");
		}

		if (mPolicy == SCHED_OTHER){
			if (mPriority != PRIO_NORMAL)	{
				struct sched_param par;
				par.sched_priority = mapPrio(mPriority, SCHED_OTHER);
				if (pthread_setschedparam(mThreadID, SCHED_OTHER, &par)){
					//throw SystemException("cannot set thread priority");
				}
			}
		}else{
			struct sched_param par;
			par.sched_priority = mPriority;
			if (pthread_setschedparam(mThreadID, mPolicy, &par)){
				//throw SystemException("cannot set thread priority");
			}
		}
	}


	void CThread::join(){
		//mEvent.wait();
		void* result;
		if (pthread_join(mThreadID, &result)){
			//throw SystemException("cannot join thread"); 
		}
	}


	bool CThread::join(long milliseconds){
		if (mEvent.wait(milliseconds)){
			void* result;
			if (pthread_join(mThreadID, &result)){
				//throw SystemException("cannot join thread");
			}
			return true;
		} else {
			return false;
		}
	}


	CThread* CThread::getCurrentThread(){
		return mCurrentHolder.get();
	}



	CThread::TID CThread::getCurrentNativeID(){
		return pthread_self();
	}


	void CThread::sleep(long milliseconds){
		struct timespec ts;
		struct timespec leftover;
		s32 rc;
		ts.tv_sec  = (long) milliseconds/1000;
		ts.tv_nsec = (long) milliseconds%1000*1000000;

		do{
			rc = ::nanosleep(&ts, &leftover);
			if (rc < 0){
				if(errno == EINTR)	{
					ts = leftover;
				}else{
					//throw SystemException("CThread::sleep(): nanosleep() failed");
					break;
				}
			}
		}while (rc!=0);

#if 0
		*Timespan remainingTime(1000**Timespan::TimeDiff(milliseconds));
		s32 rc;
		do{
			struct timeval tv;
			tv.tv_sec  = (long) remainingTime.totalSeconds();
			tv.tv_usec = (long) remainingTime.useconds();
			*Timestamp start;
			rc = ::select(0, NULL, NULL, NULL, &tv);
			if (rc < 0 && errno == EINTR)	{
				*Timestamp end;
				*Timespan waited = start.elapsed();
				if (waited < remainingTime)
					remainingTime -= waited;
				else
					remainingTime = 0;
			}
		}while (remainingTime > 0 && rc < 0 && errno == EINTR);
		if (rc < 0 && remainingTime > 0){
			//throw SystemException("CThread::sleep(): select() failed");
		}
#endif
	}


	void* CThread::runnableEntry(void* iThread){
		CThread* pThreadImpl = reinterpret_cast<CThread*>(iThread);
		mCurrentHolder.set(pThreadImpl);

		sigset_t sset;
		sigemptyset(&sset);
		sigaddset(&sset, SIGQUIT);
		sigaddset(&sset, SIGTERM);
		sigaddset(&sset, SIGPIPE);
		pthread_sigmask(SIG_BLOCK, &sset, 0);
		
		pThreadImpl->mRunnableTarget->run();
		pThreadImpl->mRunnableTarget = 0;
		//pThreadImpl->mEvent.set();
		return 0;
	}


	void* CThread::callableEntry(void* iThread){
		CThread* pThreadImpl = reinterpret_cast<CThread*>(iThread);
		mCurrentHolder.set(pThreadImpl);
		
		sigset_t sset;
		sigemptyset(&sset);
		sigaddset(&sset, SIGQUIT);
		sigaddset(&sset, SIGTERM);
		sigaddset(&sset, SIGPIPE);
		pthread_sigmask(SIG_BLOCK, &sset, 0);
		
		pThreadImpl->mCallbackTarget.mCallback(pThreadImpl->mCallbackTarget.mData);
		pThreadImpl->mCallbackTarget.mCallback = 0;
		pThreadImpl->mCallbackTarget.mData = 0;
		//pThreadImpl->mEvent.set();
		return 0;
	}


	s32 CThread::mapPrio(s32 iPriority, s32 iPolicy){
		s32 pmin = getMinPriority(iPolicy);
		s32 pmax = getMaxPriority(iPolicy);

		switch (iPriority){
		case PRIO_LOWEST:
			return pmin;
		case PRIO_LOW:
			return pmin + (pmax - pmin)/4;
		case PRIO_NORMAL:
			return pmin + (pmax - pmin)/2;
		case PRIO_HIGH:
			return pmin + 3*(pmax - pmin)/4;
		case PRIO_HIGHEST:
			return pmax;
		default:
			//("invalid thread priority");
			return -1; // just to satisfy compiler - we'll never get here anyway
		}
	}

#endif //posix thread of APP_PLATFORM_LINUX & APP_PLATFORM_ANDROID



	bool CThread::wait(long milliseconds){
		CThread* thr = CThread::getCurrentThread();
		return !(thr->mEvent.wait(milliseconds));
	}


    bool wait(CThreadEvent& iEvent, long milliseconds){
        CThread* thr = CThread::getCurrentThread();
        return !(iEvent.wait(milliseconds));
    }


	void CThread::wakeUp(){
		mEvent.set();
	}


	void CThread::makeName(){
		mName = "#";
		mName.append(core::stringc( mID ));
	}


	s32 CThread::getUniqueID(){
		static CMutex fastMutex(EMT_NO_RECURSIVE);
		static u32 count = 0;
		CAutoLock lock(fastMutex);
		++count;
		return count;
	}


	void CThread::setName(const core::stringc& name){
		static CMutex fastMutex(EMT_NO_RECURSIVE);
		CAutoLock lock(fastMutex);
		mName = name;
	}


} //end namespace irrCThreadPool.cpp/1502326704  1000  1000  100644  5345      `
﻿#include "CThreadPool.h"
#include "IAppLogger.h"

namespace irr {


    void CThreadPool::CThreadWorker::run() {
        for(; mRunning; ) {
            if(mTask) {
                mTask->run();
                mTask = 0;
                mPool->onTask(this);
            } else if(mCallTask.mCallback) {
                mCallTask.mCallback(mCallTask.mData);
                mCallTask.mCallback = 0;
                mCallTask.mData = 0;
                mPool->onTask(this);
            } else {
                mThread.sleep(100);
            }
        }//for
    }



    CThreadPool::CThreadPool(u32 iThreadCount) : mThreadCount(iThreadCount),
        mRunning(false),
        mMaxTasks(0){
            creatThread(iThreadCount);
    }


    CThreadPool::~CThreadPool() {
        removeAll();
    }


    void CThreadPool::creatThread(u32 iCount) {
        mIdleWorker.reallocate(iCount, false);
        mBusyWorker.reallocate(iCount, false);
        mBusyWorker.set_used(iCount);
        memset(mBusyWorker.pointer(), 0, iCount * sizeof(CThreadWorker*));
        for(u32 i = 0; i < iCount; ++i) {
            mIdleWorker.push_back(new CThreadWorker(this, i));
            mIdleWorker[i]->start();
        }
        //IAppLogger::log(ELOG_INFO, "CThreadPool::creatThread", "created thereads success, total: [%d]",iCount);
    }


    void CThreadPool::removeAll() {
        mHoldTasks.clear();
        mHoldCallTasks.clear();

        for(u32 i = 0; i < mBusyWorker.size(); ++i) {
            if(mBusyWorker[i]) {
                mBusyWorker[i]->stop();
                mBusyWorker[i] = 0;
            }
        }
        for(u32 i = 0; i < mIdleWorker.size(); ++i) {
            mIdleWorker[i]->stop();
            delete mIdleWorker[i];
        }
        mIdleWorker.set_used(0);
    }


    void CThreadPool::onTask(CThreadWorker* wk) {
        mMutex.lock();
        if(mHoldTasks.size()>0) {
            core::list<IRunnable*>::Iterator it = mHoldTasks.begin();
            wk->setTask(*it);
            mHoldTasks.erase(it);
            APP_LOG(ELOG_CRITICAL, "CThreadPool::onTask", "Worker[%u] got task ----------- total idle [%u]", wk->getID(), mIdleWorker.size());
        }	else if(mHoldCallTasks.size()>0) {
            core::list<SCallbackData>::Iterator it = mHoldCallTasks.begin();
            wk->setTask((*it).mCallback, (*it).mData);
            mHoldCallTasks.erase(it);
            APP_LOG(ELOG_CRITICAL, "CThreadPool::onTask", "Worker[%u] got call task ----------- total idle [%u]", wk->getID(), mIdleWorker.size());
        }	else {
            APP_LOG(ELOG_CRITICAL, "CThreadPool::onTask", "Worker[%u] back ----------- total idle [%u]", wk->getID(), mIdleWorker.size());
            mIdleWorker.push_back(wk);
            mBusyWorker[wk->getID()] = 0;
        }
        mMutex.unlock();
    }


    void CThreadPool::start() {
        if(mRunning) {
            return;
        }
        mRunning = true;
    }


    void CThreadPool::stop() {
        if(!mRunning) {
            return;
        }
        mRunning = false;
        IAppLogger::log(ELOG_CRITICAL, "CThreadPool::stop", "sum[%u] idle[%u] busy[%u]  stopping...", mThreadCount, mIdleWorker.size(), mHoldTasks.size());
        while(mIdleWorker.size() < mThreadCount) {
            CThread::sleep(200);
            APP_LOG(ELOG_CRITICAL, "CThreadPool::stop", "sum[%u] idle[%u] calltask[%u]", mThreadCount, mIdleWorker.size(), mHoldCallTasks.size());
        }
        mHoldTasks.clear();
        mHoldCallTasks.clear();
        IAppLogger::log(ELOG_CRITICAL, "CThreadPool::stop", "all threads stoped success");
    }


    bool CThreadPool::start(AppCallable iFunc, void* iData/* = 0*/) {
        if(!iFunc || !mRunning) {
            return false;
        }

        mMutex.lock();
        bool ret = true;

        if(mIdleWorker.size()>0) {
            CThreadWorker* wk = mIdleWorker.getLast();
            mIdleWorker.set_used(mIdleWorker.size() - 1);
            mBusyWorker[wk->getID()] = wk;
            wk->setTask(iFunc, iData);
            APP_LOG(ELOG_CRITICAL, "CThreadPool::start", "Worker[%u] got call task ----------- total idle [%u]", wk->getID(), mIdleWorker.size());
        } else if(mMaxTasks>0 && mHoldCallTasks.size() >= mMaxTasks) {
            ret = false;
        } else {
            SCallbackData scd(iFunc, iData);
            mHoldCallTasks.push_back(scd);
        }


        mMutex.unlock();
        return ret;
    }


    bool CThreadPool::start(IRunnable* it) {
        if(!it || !mRunning) {
            return false;
        }
        mMutex.lock();
        bool ret = true;

        if(mIdleWorker.size()) {
            CThreadWorker* wk = mIdleWorker.getLast();
            mIdleWorker.set_used(mIdleWorker.size() - 1);
            mBusyWorker[wk->getID()] = wk;
            wk->setTask(it);
            APP_LOG(ELOG_CRITICAL, "CThreadPool::start", "Worker[%u] got task ----------- total idle [%u]", wk->getID(), mIdleWorker.size());
        } else if(mMaxTasks>0 && mHoldTasks.size() >= mMaxTasks) {
            ret = false;
        } else {
            mHoldTasks.push_back(it);
        }

        mMutex.unlock();

        return ret;
    }


}//irr

